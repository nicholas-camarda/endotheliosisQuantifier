# Spec Tasks

## Tasks

- [ ] 1. Environment and Dependency Migration
  - [x] 1.1 Verify existing environment setup and evaluate current dependencies
  - [x] 1.2 Write tests for environment validation and dependency checking
  - [x] 1.3 Update environment.yml to use fastai/PyTorch instead of TensorFlow
  - [x] 1.4 Verify existing hardware detection code and evaluate integration needs
  - [x] 1.5 Create hardware detection utilities for MPS/CUDA availability
  - [x] 1.6 Write tests for hardware detection and capability reporting
  - [x] 1.7 Implement hardware capability detection system
  - [x] 1.8 Verify all tests pass

- [ ] 2. Notebook to Python Module Conversion
  - [x] 2.1 Verify existing fastai implementations in my codebase compared to the notebooks and evaluate completeness
  - [x] 2.2 Write tests for fastai segmentation module functionality
  - [x] 2.3 Extract working fastai code from segment_mitochondria.ipynb
  - [x] 2.4 Extract working fastai code from segment_glomeruli.ipynb
  - [x] 2.5 Verify existing segmentation modules and evaluate integration approach
  - [x] 2.6 Create src/eq/segmentation/fastai_segmenter.py module
  - [x] 2.7 Implement data loading and preprocessing functions
  - [x] 2.8 Write tests for data loading and preprocessing
  - [x] 2.9 Verify all tests pass

- [ ] 3. Dual-Environment Architecture Implementation
  - [x] 3.1 Verify existing configuration management and evaluate integration needs
  - [x] 3.2 Write tests for mode selection and environment switching
  - [x] 3.3 Implement explicit mode selection system (development/production)
  - [x] 3.4 Verify existing backend handling and evaluate abstraction requirements
  - [x] 3.5 Create backend abstraction layer for MPS/CUDA switching
  - [x] 3.6 Implement automatic suggestion system based on hardware capabilities
  - [x] 3.7 Write tests for backend switching and mode validation
  - [x] 3.8 Create configuration management for mode-specific settings
  - [x] 3.9 Verify all tests pass

- [x] 4. CLI Integration and Mode Selection
  - [x] 4.1 Verify existing CLI structure and evaluate mode integration approach
  - [x] 4.2 Write tests for CLI mode selection commands
  - [x] 4.3 Update CLI interface to support --mode flag
  - [x] 4.4 Verify existing error handling and evaluate mode-specific requirements
  - [x] 4.5 Implement capability reporting commands
  - [x] 4.6 Create unified CLI interface with mode transparency
  - [x] 4.7 Write tests for CLI command consistency across modes
  - [x] 4.8 Implement mode-specific error handling and recovery
  - [x] 4.9 Verify all tests pass

- [x] 5. TensorFlow to fastai Migration
  - [x] 5.1 Verify existing TensorFlow segmentation implementation and evaluate migration scope
  - [x] 5.2 Write tests for fastai segmentation training functionality
  - [x] 5.3 Migrate train_segmenter.py from TensorFlow to fastai
  - [x] 5.4 Verify existing model architecture and evaluate fastai U-Net implementation
  - [x] 5.5 Implement fastai U-Net segmentation model
  - [x] 5.6 Verify existing data pipeline and evaluate fastai integration needs
  - [x] 5.7 Create fastai data pipeline and augmentation
  - [x] 5.8 Implement fastai training loop with mode-specific optimizations
  - [x] 5.9 Write tests for training pipeline and model performance
  - [x] 5.10 Verify all tests pass

- [x] 6. Pipeline Organization and Structure
  - [x] 6.1 Verify existing pipeline scripts and evaluate organization needs
  - [x] 6.2 Move all pipeline scripts to src/eq/pipeline/ directory
  - [x] 6.3 Clean root directory of scattered Python files
  - [x] 6.4 Organize pipeline scripts by functionality and purpose
  - [x] 6.5 Update import statements and module references
  - [x] 6.6 Verify pipeline runner location and accessibility
  - [x] 6.7 Test pipeline imports and module loading
  - [x] 6.8 Verify all tests pass

- [x] 7. Pipeline Reorganization and CLI Consolidation
  - [x] 7.1 Remove redundant main.py and consolidate with __main__.py
  - [x] 7.2 Move visualization utilities to src/eq/visualization/ directory
  - [x] 7.3 Move test scripts to tests/ directory
  - [x] 7.4 Remove duplicate pipeline runners and consolidate functionality
  - [x] 7.5 Add interactive orchestrator command to CLI
  - [x] 7.6 Update import paths and module references
  - [x] 7.7 Test consolidated CLI functionality
  - [x] 7.8 Verify all tests pass

- [x] 8. Output Directory System Implementation
  - [x] 8.1 Design data-driven output directory naming convention
  - [x] 8.2 Implement output directory creation based on input data source
  - [x] 8.3 Create organized subdirectory structure (models, plots, results, reports)
  - [x] 8.4 Implement timestamp integration for versioning
  - [x] 8.5 Add run type organization (quick, full production, smoke test)
  - [x] 8.6 Write tests for output directory system
  - [x] 8.7 Implement path management across pipeline stages
  - [x] 8.8 Verify all tests pass

- [x] 9. Pipeline Simplification and Integration
  - [x] 9.1 Remove separate visualization module and task
  - [x] 9.2 Remove redundant quick test functionality
  - [x] 9.3 Simplify pipeline to production and development modes
  - [x] 9.4 Integrate visualizations into main pipeline stages
  - [x] 9.5 Update CLI to reflect simplified structure
  - [x] 9.6 Make epochs configurable rather than separate functions
  - [x] 9.7 Update tasks and spec to reflect simplified structure
  - [x] 9.8 Verify all tests pass

- [ ] 10. Three-Stage Pipeline Architecture Implementation
  - [x] 10.1 Rename current "pipeline" command to "production" (end-to-end inference)
  - [x] 10.2 Create "seg" command for segmentation training
  - [x] 10.3 Create "quant-endo" command for quantification training
  - [x] 10.4 Update orchestrator with stage-specific options
  - [x] 10.5 Implement segmentation training workflow (preserve existing notebook logic)
  - [ ] 10.6 Implement quantification training workflow (ROI extraction + regression)
  - [ ] 10.7 Implement production inference workflow (end-to-end using pre-trained models)
  - [ ] 10.8 Implement QUICK_TEST mode for all stages (fast validation mode)
  - [ ] 10.9 Write tests for each pipeline stage
  - [ ] 10.10 Verify all tests pass

- [ ] 11. Comprehensive Reporting System
  - [ ] 11.1 Design pipeline progression tracking system
  - [ ] 11.2 Implement stage-specific reporting for each pipeline stage
  - [ ] 11.3 Create performance metrics collection and display
  - [ ] 11.4 Implement quality assessment metrics and visualization
  - [ ] 11.5 Add comprehensive error reporting with recovery suggestions
  - [ ] 11.6 Create executive summary reports
  - [ ] 11.7 Write tests for reporting system
  - [ ] 11.8 Verify all tests pass

- [ ] 12. ROI and Feature Visualization
  - [ ] 12.1 Implement ROI extraction display and visualization
  - [ ] 12.2 Create patch visualization for extracted regions
  - [ ] 12.3 Implement feature distribution plots and histograms
  - [ ] 12.4 Create feature correlation matrices and importance plots
  - [ ] 12.5 Add quality metrics visualization for ROI and features
  - [ ] 12.6 Write tests for ROI and feature visualization
  - [ ] 12.7 Verify all tests pass

- [ ] 13. Regression Model Visualization
  - [ ] 13.1 Implement training curves visualization (loss, accuracy)
  - [ ] 13.2 Create validation plots and cross-validation results
  - [ ] 13.3 Implement prediction visualization (predicted vs. actual)
  - [ ] 13.4 Add confidence intervals and uncertainty visualization
  - [ ] 13.5 Create feature importance plots and coefficient analysis
  - [ ] 13.6 Implement model comparison visualization
  - [ ] 13.7 Write tests for regression visualization
  - [ ] 13.8 Verify all tests pass

## Implementation Notes

### Technical Dependencies
- Task 1 must be completed before Task 2 (environment setup)
- Task 2 must be completed before Task 3 (module availability)
- Task 3 must be completed before Task 4 (architecture foundation)
- Task 4 can be developed in parallel with Task 5 (CLI and migration)
- Task 6 (Pipeline Organization) is completed and provides foundation for Tasks 7-13
- Task 7 (Pipeline Reorganization) is completed and consolidates CLI functionality
- Task 8 (Output Directory System) is completed and provides organized output structure
- Task 9 (Pipeline Simplification) is completed and provides clean, integrated pipeline
- Task 10 (Three-Stage Pipeline) should be completed before Tasks 11-13 (reporting and visualization)
- Tasks 11-13 can be developed in parallel after Task 10 completion

### Testing Strategy
- Each major task follows TDD approach with tests written first
- Verification steps ensure existing functionality is evaluated before implementation
- Hardware detection tests will use mocking for cross-platform validation
- Mode selection tests will validate both development and production paths
- Integration tests will verify end-to-end pipeline functionality
- Output directory tests will validate naming conventions and structure

### Key Deliverables
- Dual-environment architecture with explicit mode selection
- Hardware capability detection and reporting system
- Unified CLI interface with mode transparency and interactive orchestrator
- fastai/PyTorch segmentation pipeline
- Organized pipeline structure with proper package organization
- Consolidated CLI with single entry point (__main__.py)
- Data-driven output directory system with organized outputs
- Three-stage pipeline architecture (seg, quant-endo, production)
- Comprehensive reporting system with interactive visualizations
- ROI and feature extraction visualization
- Regression model training and prediction visualization
- Comprehensive testing suite for all components

### Pipeline Organization Status
- **COMPLETED**: All pipeline scripts moved to `src/eq/pipeline/`
- **COMPLETED**: Root directory cleaned of scattered Python files
- **COMPLETED**: Test scripts moved to `tests/` directory
- **COMPLETED**: Redundant main.py removed, consolidated with __main__.py
- **COMPLETED**: Interactive orchestrator added to CLI
- **COMPLETED**: Proper package structure and import organization
- **COMPLETED**: Output directory system with data-driven naming and organized structure
- **COMPLETED**: Pipeline simplified to production and development modes with integrated visualizations
- **NEXT**: Implement three-stage pipeline architecture (seg, quant-endo, production)

### Current CLI Structure
```
python -m eq orchestrator     # Interactive menu
python -m eq pipeline         # Full pipeline (to be renamed to production)
python -m eq capabilities     # Hardware report
python -m eq mode --show      # Mode management
```

### Planned CLI Structure
```
python -m eq seg              # Segmentation training
python -m eq quant-endo       # Quantification training
python -m eq production       # End-to-end inference
python -m eq orchestrator     # Interactive menu
python -m eq capabilities     # Hardware report
python -m eq mode --show      # Mode management

# QUICK_TEST mode for all commands:
QUICK_TEST=true python -m eq seg
QUICK_TEST=true python -m eq quant-endo
QUICK_TEST=true python -m eq production
```

### Three-Stage Pipeline Architecture
- **Stage 1 (seg)**: Train segmentation model to find glomeruli
- **Stage 2 (quant-endo)**: Use segmenter to extract ROIs, train regression model
- **Stage 3 (production)**: End-to-end inference using all pre-trained models
- **QUICK_TEST Mode**: All stages support fast validation mode for development and testing
- **Integrated Visualizations**: Training curves, inference examples, model architecture
- **Configurable Epochs**: User can specify number of epochs for any mode

### Output Directory System Features
- **Data-driven naming**: Outputs organized by input data directory name
- **Timestamp integration**: Automatic versioning with timestamps
- **Run type organization**: Separate outputs for each pipeline stage
- **Structured subdirectories**: models, plots, results, reports, logs, cache
- **Metadata tracking**: JSON metadata files for each run
- **Run summaries**: Comprehensive markdown reports
- **Cleanup utilities**: Automatic cleanup of old output directories
